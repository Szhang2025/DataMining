<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Random Forest – mtry + Best Split</title>
  <style>
    body{font-family:Arial,sans-serif;margin:20px;background:#f9f9f9;color:#333;}
    .container{max-width:1200px;margin:auto;}
    textarea{width:100%;height:150px;font-family:monospace;padding:10px;border:1px solid #ccc;border-radius:5px;}
    button{background:#27ae60;color:white;padding:10px 20px;margin:5px;border:none;border-radius:5px;cursor:pointer;}
    button:hover{background:#1e8449;}
    input[type=number]{width:70px;padding:8px;border:1px solid #ccc;border-radius:5px;}
    .step{margin:20px 0;padding:15px;background:white;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.1);}
    table{border-collapse:collapse;width:100%;margin:10px 0;font-size:14px;}
    th,td{border:1px solid #ddd;padding:8px;text-align:center;}
    th{background:#2c3e50;color:white;}
    .tree{font-family:monospace;background:#f4f4f4;padding:12px;border-radius:5px;margin:10px 0;white-space:pre;}
    .highlight{background:#fff3cd;font-weight:bold;}
    .error{color:#c00;font-weight:bold;}
    .accuracy{font-weight:bold;color:#27ae60;font-size:16px;}
    .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:15px 0;}
    .info{font-size:13px;color:#555;margin:5px 0;}
  </style>
</head>
<body>
  <div class="container">
    <h1>Random Forest – mtry + Best Split</h1>
    <p>CSV: max 5 features + target, 20 rows. Target: <code>+1</code>, <code>-1</code>, <code>1</code></p>

    <textarea id="dataInput">age,income,education,experience,credit_score,target
35,60000,3,5,720,+1
28,45000,2,3,680,-1
45,80000,4,10,750,+1
32,52000,3,6,710,-1
40,70000,3,8,730,-1
29,48000,2,4,690,-1
50,90000,5,15,780,+1
31,55000,3,7,705,+1
38,65000,4,9,740,+1
27,42000,2,2,670,-1</textarea>

    <div class="controls">
      <label>Trees: <input type="number" id="nTrees" value="3" min="1" max="20"/></label>
      <label>mtry: <input type="number" id="mtry" value="2" min="1" max="5"/></label>
      <button onclick="run()">Run Forest</button>
      <div style="margin-left:20px;">
        <label>Show Tree: <input type="number" id="showTreeNum" min="1" placeholder="1"/></label>
        <button onclick="showSingleTree()">Show</button>
      </div>
      <button onclick="startOver()">Start Over</button>
    </div>

    <div id="out"></div>
  </div>

  <script>
    let globalTrees = [];
    let globalData = [];
    let globalTarget = '';
    let globalFeats = [];

    function run() {
      const out = document.getElementById('out');
      out.innerHTML = '';
      const text = document.getElementById('dataInput').value.trim();
      const nTrees = +document.getElementById('nTrees').value || 3;
      const mtry = Math.min(5, Math.max(1, +document.getElementById('mtry').value || 2));

      // ---------- Parse CSV ----------
      const lines = text.split('\n').map(l => l.trim()).filter(l => l);
      if (lines.length < 2) return error('Need header + data');
      const header = lines[0].split(',').map(h => h.trim());
      const rawData = lines.slice(1).map((l, i) => {
        const vals = l.split(',').map(v => v.trim());
        if (vals.length !== header.length) return error(`Row ${i+2}: wrong cols`);
        const row = { id: i+1 };
        header.forEach((h, j) => {
          const v = vals[j];
          row[h] = isNaN(v) ? v : +v;
        });
        const t = vals[vals.length-1];
        const norm = (t==='1'||t==='+1')?'+1':(t==='0'||t==='-1')?'-1':null;
        if (!norm) return error(`Target "${t}" in row ${i+2}`);
        row[header[header.length-1]] = norm;
        return row;
      });
      if (rawData.some(d => !d)) return;

      globalData = rawData;
      globalTarget = header[header.length-1];
      globalFeats = header.slice(0, -1);

      // ---------- Show original data ----------
      out.innerHTML += `<div class="step"><h2>Data (${globalData.length} rows, ${globalFeats.length} features)</h2>${tbl(globalData)}</div>`;

      globalTrees = [];
      for (let t = 1; t <= nTrees; t++) {
        // ---- Bootstrap sample (with replacement) ----
        const sample = [];
        for (let i = 0; i < globalData.length; i++) {
          sample.push(globalData[Math.floor(Math.random() * globalData.length)]);
        }

        // ---- Randomly select mtry features ----
        const shuffled = [...globalFeats].sort(() => 0.5 - Math.random());
        const selectedFeats = shuffled.slice(0, mtry);

        // ---- Build tree using only selected features ----
        const tree = buildTree(sample, selectedFeats, globalTarget, t);
        tree.selectedFeats = selectedFeats;
        tree.sample = sample;
        globalTrees.push(tree);

        // ---- Bootstrap table (draw order) ----
        const bootTbl = sample.map((r, i) => ({draw: i+1, ...r}));
        out.innerHTML += `<div class="step"><h2>Tree ${t}</h2>`;

        // ---- Show mtry features ----
        out.innerHTML += `<p class="info"><strong>Random Features (mtry=${mtry}):</strong> ${selectedFeats.join(', ')}</p>`;

        // ---- Show best root split ----
        const root = tree.root;
        if (root.leaf) {
          out.innerHTML += `<p class="info"><strong>Best Split:</strong> Leaf (pure or no improvement)</p>`;
        } else {
          out.innerHTML += `<p class="info highlight"><strong>Best Split:</strong> ${root.f} &le; ${root.th.toFixed(2)}</p>`;
        }

        out.innerHTML += `<p><strong>Bootstrap (draw order):</strong></p>${tbl(bootTbl)}`;
        out.innerHTML += `<div class="tree">${tree.rule}</div>`;

        // ---- Tree predictions on original data ----
        const preds = globalData.map(r => {
          const p = predict(tree, r);
          return {id: r.id, ...r, pred: p, correct: r[globalTarget]===p?'Yes':'No'};
        });
        out.innerHTML += `<p><strong>Tree ${t} Predictions:</strong></p>${tbl(preds)}</div>`;
      }

      // ---------- Final ensemble ----------
      out.innerHTML += `<div class="step"><h2>Final Vote (${nTrees} trees, mtry=${mtry})</h2>`;
      const final = globalData.map(r => {
        const votes = {'+1':0, '-1':0};
        const cols = {};
        globalTrees.forEach((tree, i) => {
          const p = predict(tree, r);
          votes[p]++;
          cols[`T${i+1}`] = p;
        });
        const rf = votes['+1'] > votes['-1'] ? '+1' : '-1';
        const correct = r[globalTarget] === rf ? 'Yes' : 'No';
        return {id: r.id, ...r, ...cols, '+1': votes['+1'], '-1': votes['-1'], RF: rf, Correct: correct};
      });
      out.innerHTML += tbl(final);
      const acc = final.filter(x => x.Correct === 'Yes').length / final.length;
      out.innerHTML += `<p class="accuracy">Accuracy: ${(acc*100).toFixed(1)}%</p></div>`;
    }

    function showSingleTree() {
      const num = +document.getElementById('showTreeNum').value;
      if (!globalTrees.length) return error('Run forest first!');
      if (num < 1 || num > globalTrees.length) return error(`Tree ${num} not found. Use 1–${globalTrees.length}`);

      const out = document.getElementById('out');
      out.innerHTML = '';

      const tree = globalTrees[num-1];
      const sample = tree.sample;

      out.innerHTML += `<div class="step"><h2>Tree ${num} (on demand)</h2>`;
      out.innerHTML += `<p class="info"><strong>Random Features (mtry=${tree.selectedFeats.length}):</strong> ${tree.selectedFeats.join(', ')}</p>`;

      const root = tree.root;
      if (root.leaf) {
        out.innerHTML += `<p class="info"><strong>Best Split:</strong> Leaf</p>`;
      } else {
        out.innerHTML += `<p class="info highlight"><strong>Best Split:</strong> ${root.f} &le; ${root.th.toFixed(2)}</p>`;
      }

      const bootTbl = sample.map((r, i) => ({draw: i+1, ...r}));
      out.innerHTML += `<p><strong>Bootstrap Sample:</strong></p>${tbl(bootTbl)}`;
      out.innerHTML += `<div class="tree">${tree.rule}</div>`;

      const preds = globalData.map(r => {
        const p = predict(tree, r);
        return {id: r.id, ...r, pred: p, correct: r[globalTarget]===p?'Yes':'No'};
      });
      out.innerHTML += `<p><strong>Tree ${num} Predictions:</strong></p>${tbl(preds)}</div>`;
    }

    function startOver() {
      document.getElementById('dataInput').value = `age,income,education,experience,credit_score,target
35,60000,3,5,720,+1
28,45000,2,3,680,-1
45,80000,4,10,750,+1
32,52000,3,6,710,+1
40,70000,3,8,730,+1
29,48000,2,4,690,-1
50,90000,5,15,780,+1
31,55000,3,7,705,+1
38,65000,4,9,740,+1
27,42000,2,2,670,-1`;
      document.getElementById('out').innerHTML = '';
      document.getElementById('nTrees').value = 3;
      document.getElementById('mtry').value = 2;
      document.getElementById('showTreeNum').value = '';
    }

    function error(msg) {
      document.getElementById('out').innerHTML = `<p class="error">Error: ${msg}</p>`;
    }

    function tbl(arr) {
      if (!arr.length) return '';
      const cols = Object.keys(arr[0]);
      let html = '<table><tr>' + cols.map(c => `<th>${c}</th>`).join('') + '</tr>';
      arr.forEach(r => {
        html += '<tr>' + cols.map(c => `<td>${r[c]}</td>`).join('') + '</tr>';
      });
      return html + '</table>';
    }

    /* --------------------------------------------------------------
       Tree building – stores left/right sub-trees
       -------------------------------------------------------------- */
    function buildTree(data, feats, target, id) {
      const root = split(data, feats, target);
      const rule = printRule(root, feats, target, id);
      return {root, rule, predict: r => predict({root}, r)};
    }

    function split(data, feats, target) {
      if (data.length === 0 || feats.length === 0 || pure(data, target)) {
        return {leaf: true, label: majority(data, target)};
      }

      let best = {err: Infinity};
      for (const f of feats) {
        const vals = [...new Set(data.map(r => r[f]))].sort((a,b) => a-b);
        for (let i = 0; i < vals.length-1; i++) {
          const th = (vals[i] + vals[i+1]) / 2;
          const L = [], R = [];
          data.forEach(r => (r[f] <= th ? L : R).push(r));
          const err = mis(L, target) + mis(R, target);
          if (err < best.err) {
            best = {f, th, L, R, err, labelL: majority(L,target), labelR: majority(R,target)};
          }
        }
      }

      if (best.err === Infinity) return {leaf:true, label:majority(data,target)};

      best.left  = split(best.L, feats, target);
      best.right = split(best.R, feats, target);
      delete best.L; delete best.R;
      return best;
    }

    function pure(d, t) { return d.length === 0 || d.every(r => r[t] === d[0][t]); }
    function majority(d, t) {
      if (d.length === 0) return '+1';
      const c = d.filter(r => r[t] === '+1').length;
      return c >= d.length/2 ? '+1' : '-1';
    }
    function mis(g, t) { if (!g.length) return 0; const c = g.filter(r=>r[t]==='+1').length; return Math.min(c, g.length-c); }

    /* --------------------------------------------------------------
       Rule printer – uses stored sub-trees
       -------------------------------------------------------------- */
    function printRule(node, feats, target, id) {
      if (node.leaf) return `Tree ${id}: → ${node.label}`;

      const left  = node.left.leaf  ? node.left.label  : printRule(node.left,  feats, target, '');
      const right = node.right.leaf ? node.right.label : printRule(node.right, feats, target, '');

      return `Tree ${id}:\nif ${node.f} <= ${node.th.toFixed(2)}:\n  ${left}\nelse:\n  ${right}`;
    }

    /* --------------------------------------------------------------
       Prediction – follows stored sub-trees
       -------------------------------------------------------------- */
    function predict(tree, row) {
      let n = tree.root;
      let depth = 0;
      while (depth < 2 && !n.leaf) {
        if (row[n.f] <= n.th) {
          if (n.left.leaf) return n.left.label;
          n = n.left;
        } else {
          if (n.right.leaf) return n.right.label;
          n = n.right;
        }
        depth++;
      }
      return n.leaf ? n.label : (row[n.f] <= n.th ? n.left.label : n.right.label);
    }
  </script>
</body>
</html>
